                                             
                                                          +-----------------------------------------+
                                                            Design Document for Project 1: Phase 01
                                                          +-----------------------------------------+                                                         


+---------- GROUPS ------------+

* Anirudh Nallana <anallana@buffalo.edu>
* Priyanka Garg  <pgarg2@buffalo.edu>
* Aishwarya Chand <achand3@buffalo.edu>
                                                          
## Task 1: Efficient Alarm Clock

+------- DATA STRUCTURES -------+

New Data Structures:


###### In timer.h

/* Phase 1 Changes */
/* Timer sleeper */
struct timer_sleeper 
  {
    struct semaphore timer_sema; /* Counting semaphore for timer */
    int amount_ticks;            /* To save the info of start(start timer tick)+ticks(sleep time of alarm clock) of interrupter */
    struct list_elem elem;       /* List elem to use with a queue list */
  };

static struct list waiting_queue; /* Waiting Queue for Timer sleeper */
static struct lock queue_lock;    /* Lock Synchronization for waiting_queue */

###### In timer.c

/* Sleeps for approximately TICKS timer ticks.  Interrupts must
   be turned on. */
void
timer_sleep (int64_t ticks) 
{
  int64_t start = timer_ticks ();

  ASSERT (intr_get_level () == INTR_ON);
  
  /* Phase 1 Changes :- */
  struct timer_sleeper cur;
  sema_init (&cur.timer_sema, 0);
  cur.amount_ticks = start+ticks;

  /* Synchronization for `waiting_queue` using `queue_lock` */
  lock_acquire (&queue_lock);
  list_push_back (&waiting_queue, &cur.elem);
  lock_release (&queue_lock);

  sema_down (&cur.timer_sema);
}


/* Timer interrupt handler. */
static void
timer_interrupt (struct intr_frame *args UNUSED)
{
  ticks++;
  
  /* Phase 1 Changes :- */
  /* Iterate through the `waiting_queue` to wake up threads using `sema_up()` */
  struct timer_sleeper* cur;
  struct list_elem* next = list_begin (&waiting_queue);
  while (next != list_end (&waiting_queue))
  {
    cur = list_entry (next, struct timer_sleeper, elem);
    if (cur->amount_ticks <= ticks)
      {
        sema_up (&cur->timer_sema);
        next = list_remove (next);  /* Remove list_elem after waking up thread */
      }
    else
        next = list_next (next);
  }
  
  thread_tick ();
}


+------- Algorithm --------+

---A2---

* timer_sleep():
 
 >> Instead of busy waiting, the current thread blocks on a semaphore timer_sema. 

 >> First, we calculate the wake-up time by adding the current timer_ticks() to the ticks value provided an this calculated wake-up time is stored in the amount_ticks field of a newly created timer_sleeper structure. 

 >> A timer_sleeper structure is created, storing the thread's wake-up time and a semaphore to block the thread.The semaphore is also initialized within this structure.

 >> The thread is added to the waiting_queue and then blocks itself by calling sema_down().

 >> The timer interrupt handler periodically checks the waiting_queue and wakes up threads whose sleep time has expired by calling sema_up() and  removing them from the queue.

---A3:---

>> The timer interrupt handler iterates through the waiting_queue and only performs minimal operationslike checking if the current time (ticks) has surpassed the threadâ€™s wake-up time.
>> Threads that are ready to wake up are immediately removed from the waiting_queue using list_remove(). 

+---- Synchronization ------+

>> In our code in order to ensure safe access to shared resources like the sleeping_list, we need to enforce synchronization because the sleep_list is     accessed by multiple threads concurrently. 

>> Since Pintos' lists are not inherently thread-safe, we use a lock, sleepling_list_lock, to manage access.

>> When inserting elements from the sleeping_list the lock is acquired to prevent race conditions between multiple threads.

>> After the operation, the lock is released, allowing other threads to access the list.

>> Additionally, each sleeping thread blocks on a unique semaphore (sema_down()) until it is time to wake up, ensuring that no unnecessary CPU cycles are wasted by busy waiting.


+---------- Rationale ---------+
>> The advantage of our implementation is that it is simple and effective.
 
>> A disadvantage we can consider may occur for large test cases with multiple number of threads, which may cause unnecessarily iterating the entire waiting_queue structure. 

>> This can be mitigated if the waiting_queue is sorted, but we chose to not implement this to avoid unwanted issues such as causing irregularities in timer ticks intervals.

>> Additionally, the time complexity is O(n)( where n is the length of the waiting_queue), which didn't call for this optimization.



+----------------------------------------------------------------------------------------------------------------------------------------------+